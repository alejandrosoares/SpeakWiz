"""
This module provides the implementation of the TopicGeneratorService class, 
which is responsible for generating new topics based on a given setup model, topic model, and tag model.
It uses a language model to generate topics and handles the creation and storage of these topics.
Classes:
    TopicGeneratorService: A service class for generating topics using a language model and storing them in the database.
    Methods:
        __init__(self, setup: TopicGeneratorSetup, tag: TopicTag, topic_model: Type[Topic]) -> None:
            Initializes the TopicGeneratorService with the given setup instance, tag instance and topic model.
        generate(self) -> None:
            Generates a new topic using the language model and stores it in the database.
Functions:
    generate_new_topic_from_random_topictag() -> None: 
        Helper function that creates an instance of TopicGeneratorService and generates a new topic using a default setup model, topic model, and tag model.
"""
import json
from typing import Type
import logging

from langchain.schema.output_parser import StrOutputParser

from llm_settings.implementations import LLMModelFactory
from topics.models import Topic, TopicTag
from topic_generator.models import TopicGeneratorSetup


_SETUP_MODEL = TopicGeneratorSetup
_TOPIC_MODEL = Topic
_TOPICTAG_MODEL = TopicTag


logger = logging.getLogger("topic_generator")


class TopicGeneratorService:
    """Service for generating topics using an LLM and storing them in the database."""

    def __init__(self, setup: TopicGeneratorSetup, tag: TopicTag, topic_model: Type[Topic]) -> None:
        self.topic_model = topic_model
        self.setup = setup
        self.tag = tag

    def generate(self) -> None:
        """Generates a new topic and saves it to the database."""
        model = LLMModelFactory.get_model(self.setup.model)
        chain = model | StrOutputParser() | json.loads
        prompt = self._get_prompt()
        try:
            response = chain.invoke(prompt)
        except Exception as e:
            logger.error("Error parsing response: (%s) %s", type(e).__name__, e, exc_info=True)
            logger.debug("Response: %s", response)
            logger.debug("Prompt: %s", prompt)
        else:
            topic_content = {
                "is_autogenerated": True,
                "tag": self.tag,
                **response
            }
            self._save_topic(topic_content)

    def _save_topic(self, topic_content: dict) -> None:
        try:
            topic = self.topic_model.objects.create(**topic_content)
        except TypeError as e:
            logger.error("Error creation instance: %s", e, exc_info=True)
            logger.debug("Topic content: %s", topic_content)
        else:
            logger.info("New topic was generated successfully: id: %s title: %s", topic.id, topic.title)
        
    def _get_prompt(self) -> str:
        template = self.setup.template
        template = template.replace("{topic}", self.tag.title)
        add_examples = self.setup.examples_to_add > 0
        prompt = self._add_examples(template) if add_examples else template
        return prompt

    def _add_examples(self, template: str) -> str:
        examples = self._get_topic_examples()
        template += f"Here are some examples of the topic:\n\n{examples}"
        return template

    def _get_topic_examples(self) -> str:
        topics = self.topic_model.objects.filter(is_enabled=True)[
            : self.setup.examples_to_add
        ]
        topics_text = []

        for index, topic in enumerate(topics):
            content = "- Example {}: {}\n{}".format(
                index,
                topic.title,
                "\n".join(
                    f"{idx}. {question}"
                    for idx, question in enumerate(topic.questions, start=1)
                ),
            )
            topics_text.append(content)
        return "\n\n".join(topics_text)


def generate_new_topic_from_random_topictag() -> None:
    # Assuming it is possible the have only one setup active at a time
    setup = _SETUP_MODEL.objects.filter(is_enabled=True).first()

    if not setup:
        logger.info("No active setup found.")
        return

    # Get a random instance
    tag = _TOPICTAG_MODEL.objects.order_by('?').first()

    topic_generator = TopicGeneratorService(
        setup=setup,
        tag=tag,
        topic_model=_TOPIC_MODEL
    )
    topic_generator.generate()
