from abc import ABC, abstractmethod

from random import choice
from json.decoder import JSONDecodeError

from cards.models import Card
from topics.models import Topic, TopicTag
from services.model import LLModelSingleton
from services.topics.generate.formatters import TopicFormatter, TagFormatter
from services.topics.generate.parsers import TopicParserSingleton, TopicOutput
from services.topics.generate.prompts import TopicPromptSingleton
from services.topics.generate.prompts.instructions import (
    CREATE_FROM_EXISTING_INSTRUCTION,
    CREATE_NEW_INSTRUCTION
)
from services.topics.generate.validators import TopicGeneratorValidator


class ITopicGenerator(ABC):

    @abstractmethod
    def start(self) -> None:
        pass


class TopicGeneratorBase(ITopicGenerator):

    class Meta:
        abstract = True
                
    def _get_input_for_model(self, input_context: str) -> str:
        _input = self.prompt.format_prompt(
            instruction=self.cls.instructions,
            input_context=input_context
        )
        return _input.to_string()
    
    def _get_output_from_model(self, _input: str) -> str:
        output = self.model(_input)
        return output

    def _parse_output(self, output: str) -> TopicOutput:
        try:
            topic_output = self.parser.parse(output)
        except JSONDecodeError as error:
            print(f'ERROR: Parsing output :{error}')
            topic_output = None
        return topic_output
    
    @abstractmethod
    def _save_output(self, topic_output):
        pass

    @abstractmethod
    def _get_tag(self):
        pass


class TopicGeneratorFromExisting(TopicGeneratorBase):

    instructions = CREATE_FROM_EXISTING_INSTRUCTION

    def __init__(self) -> None:
        self.tag = self._get_tag()
        self.topics = self.tag.topics.all()
        self.model = LLModelSingleton.get_instance()
        self.prompt = TopicPromptSingleton.get_instance()
        self.parser = TopicParserSingleton.get_instance()
        self.formatter =  TopicFormatter(self.tag, self.topics)
        self.cls = TopicGeneratorFromExisting

    def start(self):
        input_context = self.formatter.get_input_context()
        _input = self._get_input_for_model(input_context)
        output = self._get_output_from_model(_input)
        topic_output = self._parse_output(output)     
        if topic_output:
            self._save_output(topic_output)

    def _save_output(self, topic_output):
        is_valid = self.__validate_output(topic_output)
        new_topic = Topic.create(topic_output.title, topic_output.description, enabled=is_valid, autogenerated = True)
        Card.create_cards_of_topic(new_topic, topic_output.questions)
        self.tag.topics.add(new_topic)

    def _get_tag(self) -> TopicTag:
        tag = self.__get_random_tag()
        return tag

    def __get_random_tag(self) -> str:
        tags = TopicTag.objects \
                .filter(number_topics__gt=0) \
                .order_by('number_topics')
        tag = choice(tags)
        return tag

    def __validate_output(self, topic_output: TopicOutput):
        self.validator = TopicGeneratorValidator(self.topics, topic_output)
        return self.validator.validate()


class TopicGeneratorFromScratch(TopicGeneratorBase):

    instructions = CREATE_NEW_INSTRUCTION

    def __init__(self) -> None:
        self.model = LLModelSingleton.get_instance()
        self.prompt = TopicPromptSingleton.get_instance()
        self.parser = TopicParserSingleton.get_instance()
        self.cls = TopicGeneratorFromScratch

    def start(self):
        if TopicTag.objects.filter(number_topics=0).count() > 0:
            self.tag = self._get_tag()
            self.formatter =  TagFormatter(self.tag)
            input_context = self.formatter.get_input_context()
            _input = self._get_input_for_model(input_context)
            output = self._get_output_from_model(_input)
            topic_output = self._parse_output(output)     
            if topic_output:
                self._save_output(topic_output)

    def _save_output(self, topic_output):
        new_topic = Topic.create(topic_output.title, topic_output.description, enabled=True, autogenerated = True)
        Card.create_cards_of_topic(new_topic, topic_output.questions)
        self.tag.topics.add(new_topic)
    
    def _get_tag(self) -> TopicTag:
        tag = self.__get_empty_tag()
        return tag
    
    def __get_empty_tag(self) -> TopicTag:
        empty_tags = TopicTag.objects.filter(number_topics=0)
        tag = choice(empty_tags)
        return tag
